// Jenkinsfile - 自动化镜像构建与测试流水线
def DYNAMIC_IMAGE_TAG // 定义一个脚本级变量来持有动态标签

pipeline {
    // 1. 定义 Agent
    agent any

    // 2. 定义环境变量
    environment {
        // 定义基础镜像名称
        IMAGE_NAME = 'testenv'
        // 定义默认的稳定镜像版本，当Dockerfile未更新时使用
        STABLE_IMAGE_TAG = 'baseline'
        // DYNAMIC_IMAGE_TAG 从这里移除，因为它将在后面动态生成
    }

    // 定义流水线选项
    options {
        // 启用 AnsiColor 插件的开关，解析并渲染流水线中的 ANSI 颜色代码
        ansiColor('xterm')
    }

    // 3. 定义触发器
    triggers {
        // 每天凌晨 4:10-4:20 定时执行
        cron('H(10-20) 4 * * *')
    }

    stages {
        // ====================================================================
        //  阶段 1: 清理工作区
        // ====================================================================
        stage('Clean Workspace') {
            steps {
                echo "INFO: 准备为构建 #${env.BUILD_NUMBER} 清理工作区..."
                // 使用 'git clean' 代替 'cleanWs'。
                // 'git clean -fdx' 会删除所有未跟踪的文件和目录，包括被 .gitignore 忽略的文件，
                // 但会保留 .git 目录，从而保留了 git 历史，使得 Jenkins 能够正确计算增量变更。
                sh 'git clean -fdx'
                echo "SUCCESS: 工作区清理完成."
            }
        }

        // ====================================================================
        //  阶段 2: 检出代码
        // ====================================================================
        stage('Checkout SCM') {
            steps {
                script {
                    // 定义Git仓库和分支的变量
                    def gitUrl = 'https://gitee.com/changyunhuizhi/opwb-automation.git'
                    def gitBranch = env.BRANCH_NAME ?: 'main'

                    // 使用变量生成动态的日志消息
                    echo "INFO: 开始从 Gitee 仓库 [${gitUrl}] 检出代码 (分支: ${gitBranch})..."

                    retry(count: 3) {
                        // 在 git 步骤中使用变量
                        git branch: gitBranch,
                            credentialsId: '463e6b72-63de-4775-8ca4-01f465f4f33e',
                            url: gitUrl
                    }
                    echo "SUCCESS: 代码检出成功."
                }
            }
        }

        // ====================================================================
        //  阶段 3: 定义构建变量 (包括动态镜像标签)
        // ====================================================================
        stage('Define Build Vars') {
            steps {
                script {
                    // 生成 YYYYMMDD 格式的日期字符串
                    def buildDate = new Date().format('yyyyMMdd')
                    // 赋值给脚本级变量
                    DYNAMIC_IMAGE_TAG = "${buildDate}-${env.BUILD_NUMBER}"
                    echo "INFO: 本次构建生成的动态镜像标签为: ${env.IMAGE_NAME}:${DYNAMIC_IMAGE_TAG}"

                    echo "INFO: 检查本次构建的变更集以确定 Dockerfile 是否变动..."
                    // 如果是第一次构建，changeSets 可能为空，此时默认不构建镜像
                    // 只有当明确检测到 Dockerfile 变动时才构建
                    def dockerfileHasChanged = false
                    if (!currentBuild.changeSets.isEmpty()) {
                        // 遍历所有变更集
                        for (changeSet in currentBuild.changeSets) {
                            // 遍历变更集中的每个条目（通常是每个 commit）
                            for (entry in changeSet.items) {
                                // 检查受影响的文件路径
                                if (entry.affectedPaths.any { it.contains('Dockerfile') }) {
                                    dockerfileHasChanged = true
                                    // 找到一个变动就足够了，可以跳出循环
                                    break
                                }
                            }
                            if (dockerfileHasChanged) {
                                break
                            }
                        }
                    } else {
                        echo "WARNING: 本次构建变更集为空，可能为手动触发或首次构建。将假定 Dockerfile 未变动。"
                    }

                    if (dockerfileHasChanged) {
                        echo "INFO: 检测到 Dockerfile 在本次构建的变更中被修改。"
                        env.DOCKERFILE_CHANGED = 'true'
                    } else {
                        echo "INFO: 本次构建的变更集中不包含对 Dockerfile 的修改。"
                        env.DOCKERFILE_CHANGED = 'false'
                    }
                    echo "INFO: Dockerfile 是否发生变动: ${env.DOCKERFILE_CHANGED}"
                }
            }
        }

        // ====================================================================
        //  阶段 4: 构建 Docker 镜像 (仅在 Dockerfile 变动时)
        // ====================================================================
        stage('Build Docker Image') {
            when {
                // 当 DOCKERFILE_CHANGED 环境变量为 'true' 时，才执行此阶段
                expression { env.DOCKERFILE_CHANGED == 'true' }
            }
            steps {
                script {
                    // 使用脚本级变量
                    def newImageFullName = "${env.IMAGE_NAME}:${DYNAMIC_IMAGE_TAG}"
                    echo "INFO: 检测到 Dockerfile 变动，开始构建新镜像: ${newImageFullName}..."
                    // 使用 docker build 命令构建镜像
                    docker.build(newImageFullName, '.')
                    echo "SUCCESS: 新镜像 ${newImageFullName} 构建成功."
                }
            }
            // 构建成功后执行清理
            post {
                success {
                    script {
                        echo "INFO: 清理无用的悬空 Docker 镜像..."
                        sh 'docker image prune -f'
                    }
                }
            }
        }

        // ====================================================================
        //  阶段 5: 运行 API 自动化测试
        // ====================================================================
        stage('Run API Tests') {
            steps {
                script {
                    def imageToUse
                    // 如果 Dockerfile 变动了，就使用本次构建的新镜像
                    if (env.DOCKERFILE_CHANGED == 'true') {
                        // 使用脚本级变量
                        imageToUse = "${env.IMAGE_NAME}:${DYNAMIC_IMAGE_TAG}"
                        echo "INFO: 使用新构建的镜像 [${imageToUse}] 运行测试."
                    } else {
                        // 否则，使用稳定版的镜像
                        imageToUse = "${env.IMAGE_NAME}:${env.STABLE_IMAGE_TAG}"
                        echo "INFO: Dockerfile 未变动，使用稳定版镜像 [${imageToUse}] 运行测试."
                    }

                    // 启动选择好的容器来运行脚本
                    docker.image(imageToUse).inside("--volume ${WORKSPACE}:/app --volume ${WORKSPACE}/report:/app/report -w /app") {
                        sh 'python run_main_test.py --clean --type config login'
                    }
                    echo "SUCCESS: 自动化测试执行完成."
                }
            }
        }
    }

    // ====================================================================
    //  构建后操作 (优化后)
    // ====================================================================
    post {
        always {
            script {
                echo "INFO: 开始执行构建后操作..."

                // 1. 首先，无论成功与否都尝试生成 Allure 报告
                // 这样即使测试失败，也能看到失败的报告
                try {
                    allure commandline: 'Allure', includeProperties: false, jdk: '', results: [[path: 'output/report/allure-results']]
                } catch (e) {
                    echo "WARNING: Allure 报告生成失败: ${e.message}"
                }

                // 2. 然后，将原始结果目录压缩以便归档
                def reportDir = 'output/report'
                if (fileExists("${reportDir}/allure-results")) {
                    echo "INFO: 正在将 Allure 原始结果压缩..."
                    // 使用构建号命名，避免重名
                    def zipFileName = "${reportDir}/allure-results-${env.BUILD_NUMBER}.zip"
                    zip zipFile: zipFileName, dir: "${reportDir}/allure-results", overwrite: true

                    // 3. 最后，归档日志和压缩后的结果文件
                    echo "INFO: 归档日志文件和 Allure 结果压缩包..."
                    archiveArtifacts artifacts: "output/log/*, ${zipFileName}", excludes: 'output/log/.gitkeep', allowEmptyArchive: true
                } else {
                    echo "WARNING: 未找到 allure-results 目录，跳过归档。"
                    // 即使没有 allure-results，也尝试归档日志
                    archiveArtifacts artifacts: 'output/log/*', excludes: 'output/log/.gitkeep', allowEmptyArchive: true
                }

                echo "SUCCESS: 构建后操作完成."
            }
        }
    }
}