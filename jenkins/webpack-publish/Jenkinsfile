pipeline {
    // ====================================================================
    // 1. 定义构建环境
    // ====================================================================
    agent {
        docker {
            // 指定用于构建的 Docker 镜像
            image 'node:14.15.0'
            // 关键：挂载两个命名卷（named volumes），避免冲突并最大化利用缓存
            // - npm-cache: 用于缓存 npm 下载的包文件（tarballs），避免重复从网络下载
            // - node-modules-cache: 用于持久化整个 node_modules 目录，这是实现下面“极速增量安装”策略的核心基础。
            //   Webpack 的 .cache 目录是 node_modules 的子目录，因此会自动被这个卷持久化。
            args '-u root:root -v npm-cache:/root/.npm -v node-modules-cache:/workspace/node_modules --entrypoint='
        }
    }

     stages {
        // ====================================================================
        // 阶段：检出代码
        // ====================================================================
        stage('Checkout') {
            steps {
                echo 'INFO: 正在检出代码 (使用完整克隆)...'
                checkout([
                    $class: 'GitSCM',
                    branches: [[name: '*/shijiaxuan-pool']], // 指定要检出的 Git 分支
                    userRemoteConfigs: [[
                        url: 'https://gitee.com/changyunhuizhi/opwb-web.git', // Git 仓库地址
                        credentialsId: 'd5208b73-a80f-403b-a5df-365614d1362e' // Jenkins 中存储的凭证 ID
                    ]],
                    extensions: []
                ])
            }
        }

        // ====================================================================
        // 阶段：极速增量安装依赖
        // ====================================================================
        stage('Install Dependencies') {
            steps {
                sh '''
                    #!/bin/bash
                    set -e # 设置脚本在遇到任何错误时立即退出

                    echo "--> INFO: 正在开始极速增量安装..."
                    # 设置 npm 使用国内镜像源，加速包的下载过程
                    npm config set registry https://registry.npmmirror.com

                    # 核心逻辑：通过对比 package-lock.json 文件的哈希值来判断依赖是否发生变化
                    # 1. 计算当前代码中 package-lock.json 文件的 MD5 哈希值
                    CURRENT_CHECKSUM=$(md5sum package-lock.json | awk '{ print $1 }')

                    # 2. 定义一个文件，用于存储上一次成功安装后的哈希值。这个文件位于被缓存的 node_modules 目录中
                    SAVED_CHECKSUM_FILE="node_modules/.lock-checksum"

                    # 3. 判断：如果 checksum 文件存在，并且其内容与当前计算出的哈希值完全相同
                    if [ -f "$SAVED_CHECKSUM_FILE" ] && [ "$CURRENT_CHECKSUM" = "$(cat "$SAVED_CHECKSUM_FILE")" ]; then
                        # 如果哈希值未变，说明依赖包没有任何变化，直接跳过整个安装过程，将此阶段耗时从数分钟降至数秒
                        echo "--> 成功: package-lock.json 未发生变化，跳过依赖安装。"
                    else
                        # 如果哈希值有变，或者这是第一次构建（checksum 文件不存在）
                        echo "--> INFO: package-lock.json 已发生变化，正在执行增量 'npm install'。"
                        # 执行增量安装。它会读取已存在的 node_modules 目录（来自缓存卷），只更新有变化的包，速度远快于 npm ci
                        npm install --no-audit --no-fund
                        echo "--> INFO: 正在为 package-lock.json 保存新的校验和。"
                        # 4. 安装成功后，将新的哈希值写入到 checksum 文件中，为下一次构建做准备
                        echo "$CURRENT_CHECKSUM" > "$SAVED_CHECKSUM_FILE"
                    fi
                '''
            }
        }

        // ====================================================================
        // 阶段：编译项目
        // ====================================================================
        stage('Build') {
            steps {
                echo 'INFO: 正在清理旧的构建产物...'
                // 只清理最终打包的 zip 文件，Vue CLI 的 build 命令会自动清理 dist 目录
                sh 'rm -f dist.zip || true'

                // --- 注入多线程配置 ---
                script {
                    def originalConfig = readFile('vue.config.js')
                    def injectedCode = """
                    // START: Injected multi-threading config
                    const os = require('os');
                    const isProd = process.env.NODE_ENV === 'production';
                    if (isProd) {
                        console.log('正在为 Babel-loader 注入多线程配置...');
                        config.module
                            .rule('js')
                            .use('cache-loader')
                            .loader('cache-loader')
                            .end()
                            .use('thread-loader')
                            .loader('thread-loader')
                            .options({
                                workers: os.cpus().length - 1,
                                poolTimeout: 2000
                            })
                            .before('babel-loader');
                    }
                    // END: Injected multi-threading config
                    """
                    def modifiedConfig = originalConfig.replaceFirst(
                        'chainWebpack: config => \\{',
                        "chainWebpack: config => {\n${injectedCode}"
                    )
                    writeFile(file: 'vue.config.js', text: modifiedConfig)
                    echo "INFO: 已在内存中修改并写回 vue.config.js。"
                }

                // 使用 withEnv 块来临时设置环境变量
                // 同时添加环境变量，禁用 browserslist 的更新和警告
                withEnv(['NODE_OPTIONS=--max-old-space-size=8192', 'BROWSERSLIST_IGNORE_OLD_DATA=true', 'BROWSERSLIST_UPDATE=false']) {
                    echo "INFO: 使用 NODE_OPTIONS=${env.NODE_OPTIONS} 编译项目..."
                    // 核心构建命令
                    // - NODE_ENV=production: 触发所有生产环境优化（代码压缩、tree-shaking等）
                    // - npm run build: 执行在 package.json 中定义的 build 脚本
                    // - --no-lint: 跳过 ESLint 代码规范检查，专注于编译任务，加速构建
                    sh 'NODE_ENV=production npm run build -- --no-lint'
                }
            }
        }

        // ====================================================================
        // 阶段：打包产物
        // ====================================================================
        stage('Package Artifact') {
            steps {
                echo 'INFO: 正在将 dist 目录打包为 dist.zip...'
                // 进入编译生成的 dist 目录，确保 zip 包解压后直接是项目文件
                dir('dist') {
                    // 将 dist 目录下的所有内容打包成 dist.zip，并存放到上层目录
                    // 关键修复：先进入 dist 目录再打包，可以确保 zip 包解压后直接是项目文件，而不是包含一个顶层的 dist 目录
                    sh 'zip -qr ../dist.zip .'
                }
                // 将生成的 dist.zip 文件作为本次构建的产物进行归档
                // 归档后，可以方便地从 Jenkins 的构建历史页面下载，也便于其他任务或阶段使用
                archiveArtifacts artifacts: 'dist.zip', followSymlinks: false
            }
        }

        // ====================================================================
        // 阶段：部署到测试环境
        // ====================================================================
        stage('Deploy to Test') {
            steps {
                // 使用 SSH Agent 插件，它会将指定的 SSH 凭证安全地加载到环境中
                sshagent(credentials: ['ssh-key-for-test-server']) {
                    script {
                        // 定义远程服务器的连接信息和路径
                        def remoteUser = "root"
                        def remoteHost = "10.189.189.189"
                        def remoteWorkDir = "/data/server/opwbworkbench/webpack/"
                        def remoteHtmlDir = "/data/server/opwbworkbench/html"

                        echo "INFO: 正在传输 dist.zip 到测试服务器 ${remoteHost}..."
                        // 使用 scp 命令将构建产物安全地传输到远程服务器的指定工作目录
                        sh "scp -o StrictHostKeyChecking=no dist.zip ${remoteUser}@${remoteHost}:${remoteWorkDir}"

                        echo "INFO: 正在执行远程部署脚本..."
                        // 使用 ssh 命令在远程服务器上执行一连串的部署操作
                        sh """
                            ssh -o StrictHostKeyChecking=no ${remoteUser}@${remoteHost} '
                                set -e # 确保远程脚本在遇到任何错误时立即停止执行

                                # 定义远程服务器上的变量，增加可读性
                                WORK_DIR="${remoteWorkDir}"
                                HTML_DIR="${remoteHtmlDir}"
                                DIST_ZIP="dist.zip"
                                TIMESTAMP=\$(date +"%Y%m%d%-H%M%S") # 创建一个时间戳用于备份文件名
                                BACKUP_FILE="html_backup_\${TIMESTAMP}.tar.gz"
                                MAX_BACKUPS=10 # 最多保留的备份数量

                                cd \$WORK_DIR # 进入工作目录

                                echo "--> 正在备份现有应用..."
                                # 在覆盖之前，将当前的应用目录完整备份成一个 .tar.gz 文件
                                tar -czf "\$BACKUP_FILE" -C "\$(dirname "\$HTML_DIR")" "\$(basename "\$HTML_DIR")"

                                echo "--> 正在清理旧备份..."
                                # 查找所有备份文件，按时间排序，并删除除了最近 MAX_BACKUPS 个之外的所有旧备份
                                ls -1t html_backup_*.tar.gz 2>/dev/null | tail -n +\$((\$MAX_BACKUPS + 1)) | xargs -r rm -f

                                echo "--> 正在清空目标目录..."
                                # 彻底清空当前的应用目录，为新版本做准备
                                rm -rf "\${HTML_DIR:?}"/*

                                echo "--> 正在解压新版本..."
                                # 将刚刚上传的 dist.zip 解压到应用目录
                                unzip -q -o "\$DIST_ZIP" -d "\$HTML_DIR"

                                echo "--> 正在清理临时文件..."
                                # 删除上传的 zip 包
                                rm "\$DIST_ZIP"

                                echo "✅ 部署完成。"
                            '
                        """
                    }
                }
            }
        }
    }

    // ====================================================================
    // 构建后操作
    // ====================================================================
    post {
        // always 块确保无论构建成功、失败还是中止，这里面的步骤都会被执行
        always {
            echo '构建流程已结束。'
        }
    }
}
