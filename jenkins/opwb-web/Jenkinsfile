pipeline {
    // 1. 定义构建环境
    agent {
        docker {
            image 'maven:3.9.11-eclipse-temurin-21'
            args '-u root:root -v maven-m2-cache:/root/.m2/repository'
        }
    }

    stages {
        // ====================================================================
        //  阶段 1: 拉取代码
        // ====================================================================
        stage('Checkout') {
            steps {
                echo 'INFO: 开始从 Git 仓库拉取代码...'
                checkout([
                    $class: 'GitSCM',
                    branches: [[name: '*/workbench']],
                    userRemoteConfigs: [[
                        url: 'https://gitee.com/changyunhuizhi/opwb-services.git',
                        credentialsId: 'd5208b73-a80f-403b-a5df-365614d1362e'
                    ]]
                ])
            }
        }

        // ====================================================================
        //  阶段 2: 构建小包
        // ====================================================================
        stage('Build Small Package') {
            steps {
                configFileProvider([configFile(fileId: 'maven-aliyun-settings', variable: 'MAVEN_SETTINGS')]) {
                    script {
                        echo 'INFO: 开始为整个项目构建 Jar 包 (跳过测试)...'
                        // --- 修改: 添加 -Dproject.build.outputTimestamp=1 实现可重现的构建 ---
                        sh 'mvn -s ${MAVEN_SETTINGS} -T 1C clean package -Dproject.build.outputTimestamp=1 -DskipTests'

                        echo 'INFO: 开始为 opwb-web 模块分离依赖库...'
                        sh 'mvn -s ${MAVEN_SETTINGS} -T 8 -pl opwb-web dependency:copy-dependencies -DskipTests -DoutputDirectory=${WORKSPACE}/opwb-web/target/dependencies'
                        echo 'SUCCESS: 所有模块构建完成。'
                    }
                }
            }
        }

        // ====================================================================
        //  阶段 3: 创建增量包
        // ====================================================================
        stage('Create Incremental Package') {
            steps {
                script {
                    echo "INFO: 准备对接 API 获取线上清单，创建增量包..."

                    sh '''
                        #!/bin/bash
                        set -e

                        # 1. 准备目录和 API 配置
                        echo "INFO: 准备目录和 API 配置..."
                        mkdir -p update_package/lib
                        BASELINE_PATH="/var/jenkins_home/share/${JOB_NAME}/last_successful_artifacts"
                        MANIFEST_FILE="dependency-manifest.txt"

                        # API 配置
                        API_BASE_URL="http://10.189.189.189:8084"
                        PASSWORD="2T1C2]]k^T9]Kjl"

                        # 2. 登录并获取 Token
                        echo "INFO: 正在登录以获取 Token..."
                        LOGIN_RESPONSE=$(curl -s --location --request POST "${API_BASE_URL}/wt/api/terminalAuth/login" \
                        --header 'Content-Type: application/json' \
                        -d "{
                            \"password\": \"${PASSWORD}\",
                            \"type\": \"account\"
                        }")
                        TOKEN=$(echo "${LOGIN_RESPONSE}" | jq -r '.token')
                        if [ -z "$TOKEN" ] || [ "$TOKEN" == "null" ]; then
                            echo "错误: 获取授权 Token 失败。"
                            echo "登录响应: ${LOGIN_RESPONSE}"
                            exit 1
                        fi
                        echo "SUCCESS: 登录成功。"

                        # 3. 使用 Token 获取并处理线上清单
                        echo "INFO: 正在从 API 获取清单..."
                        MANIFEST_JSON=$(curl -s --location --request GET "${API_BASE_URL}/automation/getLibJarList/?path=/data/server/opwbworkbench/lib/" \
                        --header "Authorization: Bearer ${TOKEN}")

                        if [[ $(echo "${MANIFEST_JSON}" | grep -c "Internal Server Error") -gt 0 ]] || [[ -z "${MANIFEST_JSON}" ]]; then
                            echo "错误: API 返回错误或空响应。"
                            echo "API 响应: ${MANIFEST_JSON}"
                            exit 1
                        fi
                        echo "${MANIFEST_JSON}" | jq -r '.result[]' > ${MANIFEST_FILE}
                        if [ ! -s "${MANIFEST_FILE}" ]; then
                            echo "警告: 从 API 获取的清单为空，将按全量包处理。"
                        fi
                        echo "SUCCESS: 已根据 API 响应创建清单文件。"

                        # 4. 对比业务 Jar 包 (MD5内容对比)
                        echo "INFO: [1/3] 正在将自定义业务 Jar 包与上次成功构建对比..."
                        SELF_MODULES="opwb-terminal opwb-web opwb-dao opwb-bean opwb-service opwb-flow opwb-framework-core opwb-framework-entity opwb-framework-definition"

                        for module_name in ${SELF_MODULES}; do
                            MODULE_JAR_NEW=""
                            CANDIDATE=$(find "${module_name}/target" -maxdepth 1 -name "*.jar.original" 2>/dev/null)
                            if [ -z "${CANDIDATE}" ]; then
                                CANDIDATE=$(find "${module_name}/target" -maxdepth 1 -name "*.jar" ! -name "*-sources.jar" ! -name "*-javadoc.jar" ! -name "*-exec.jar" 2>/dev/null)
                            fi
                            MODULE_JAR_NEW=$(echo "${CANDIDATE}" | head -n 1)

                            if [ -z "${MODULE_JAR_NEW}" ]; then
                                echo "  -> 警告: 找不到模块 '${module_name}' 的 Jar 包，已跳过。"
                                continue
                            fi

                            MODULE_JAR_OLD_FIXED="${BASELINE_PATH}/${module_name}.jar"

                            if [ ! -f "$MODULE_JAR_OLD_FIXED" ]; then
                                echo "  -> 新增: ${module_name}.jar (无基线)，打包中。"
                                cp "$MODULE_JAR_NEW" "update_package/$(basename ${MODULE_JAR_NEW})"
                            else
                                CHECKSUM_OLD=$(md5sum "$MODULE_JAR_OLD_FIXED" | awk '{print $1}')
                                CHECKSUM_NEW=$(md5sum "$MODULE_JAR_NEW" | awk '{print $1}')
                                if [ "$CHECKSUM_OLD" != "$CHECKSUM_NEW" ]; then
                                    echo "  -> 变更: ${module_name}.jar 内容已改变，打包中。"
                                    cp "$MODULE_JAR_NEW" "update_package/$(basename ${MODULE_JAR_NEW})"
                                else
                                    echo "  -> 未变: ${module_name}.jar。"
                                fi
                            fi
                        done

                        # 5. 对比第三方依赖库 (基于API清单)
                        echo "INFO: [2/3] 正在将第三方依赖与 API 清单对比..."
                        DELETE_MANIFEST="update_package/delete.txt"
                        touch $DELETE_MANIFEST

                        CURRENT_DEPS_FILE="current_deps.txt"
                        if [ -d "opwb-web/target/dependencies" ] && [ "$(ls -A opwb-web/target/dependencies)" ]; then
                            ls -1 opwb-web/target/dependencies/ > ${CURRENT_DEPS_FILE}
                        else
                            touch ${CURRENT_DEPS_FILE}
                        fi

                        sort "${MANIFEST_FILE}" -o manifest.sorted.txt
                        sort "${CURRENT_DEPS_FILE}" -o current_deps.sorted.txt

                        comm -23 current_deps.sorted.txt manifest.sorted.txt | while IFS= read -r filename; do
                            if [ -n "$filename" ]; then
                                echo "  -> 新增: 依赖 '$filename' 不在清单中，打包中。"
                                cp "opwb-web/target/dependencies/$filename" "update_package/lib/$filename"
                            fi
                        done

                        comm -13 current_deps.sorted.txt manifest.sorted.txt | while IFS= read -r filename; do
                            if [ -n "$filename" ]; then
                                echo "  -> 删除: 依赖 '$filename' 将被添加到 delete.txt。"
                                echo "lib/$filename" >> $DELETE_MANIFEST
                            fi
                        done
                        rm -f current_deps.txt manifest.sorted.txt current_deps.sorted.txt

                        # 6. 根据是否有变更来决定是否打包
                        echo "INFO: [3/3] 正在完成打包..."
                        if [ -f "$DELETE_MANIFEST" ] && [ ! -s "$DELETE_MANIFEST" ]; then
                            rm $DELETE_MANIFEST
                        fi

                        if [ -z "$(ls -A update_package)" ]; then
                            echo "-------------------------------------------------------------"
                            echo "总结: 未检测到任何变更，无需创建更新包。"
                            echo "-------------------------------------------------------------"
                            echo "NO_CHANGES_DETECTED=true" > build_vars.properties
                        else
                            echo "-------------------------------------------------------------"
                            echo "总结: 检测到变更，正在创建更新包..."
                            echo "-------------------------------------------------------------"
                            echo "NO_CHANGES_DETECTED=false" > build_vars.properties
                            cd update_package
                            tar -czf ../update.tar.gz .
                            cd ..
                            echo "SUCCESS: 更新包 update.tar.gz 已创建。"
                        fi

                        # 7. 保存业务 Jar 包基线
                        echo "INFO: 正在为下次构建更新业务 Jar 包基线..."
                        mkdir -p "${BASELINE_PATH}"
                        for module_name in ${SELF_MODULES}; do
                            MODULE_JAR_NEW=""
                            CANDIDATE=$(find "${module_name}/target" -maxdepth 1 -name "*.jar.original" 2>/dev/null)
                            if [ -z "${CANDIDATE}" ]; then
                                CANDIDATE=$(find "${module_name}/target" -maxdepth 1 -name "*.jar" ! -name "*-sources.jar" ! -name "*-javadoc.jar" ! -name "*-exec.jar" 2>/dev/null)
                            fi
                            MODULE_JAR_NEW=$(echo "${CANDIDATE}" | head -n 1)

                            if [ -n "${MODULE_JAR_NEW}" ]; then
                                # 使用固定名称保存基线，方便下次查找
                                cp "${MODULE_JAR_NEW}" "${BASELINE_PATH}/${module_name}.jar"
                            fi
                        done
                        echo "SUCCESS: 业务 Jar 包基线已更新。"
                    '''
                    // 读取shell脚本生成的标记
                    def props = readProperties file: 'build_vars.properties'
                    env.NO_CHANGES_DETECTED = props.NO_CHANGES_DETECTED
                }
            }
        }

        // ====================================================================
        //  阶段 4: 归档到共享目录
        // ====================================================================
        stage('Archive to Share') {
            when { expression { env.NO_CHANGES_DETECTED == 'false' } }
            steps {
                script {
                    echo "INFO: 开始归档增量更新包到共享目录..."
                    def timestamp = new Date().format('yy-MM-dd_HH-mm-ss', TimeZone.getTimeZone('Asia/Shanghai'))
                    def shareRoot = "/var/jenkins_home/share"
                    def targetDir = "${shareRoot}/${env.JOB_NAME}/${env.JOB_NAME}-${timestamp}"
                    sh """
                        set -e
                        mkdir -p "${targetDir}"
                        cp update.tar.gz "${targetDir}/"
                        cat <<EOF

========================================================================
✅ 增量更新包已成功归档

  任务名称: ${env.JOB_NAME}
  构建时间: ${timestamp}
  归档路径: \\\\\\\\10.189.189.245\\\\share\\\\${env.JOB_NAME}\\\\${env.JOB_NAME}-${timestamp}

  **重要**: 如果包内包含 'delete.txt', 请在部署时优先处理。
========================================================================
EOF
                    """
                }
            }
        }

        // ====================================================================
        //  阶段 5: Jenkins 内部归档
        // ====================================================================
        stage('Archive Jenkins Artifacts') {
            when { expression { env.NO_CHANGES_DETECTED == 'false' } }
            steps {
                echo 'INFO: 开始归档增量包至 Jenkins...'
                archiveArtifacts artifacts: 'update.tar.gz', allowEmptyArchive: true
            }
        }
    }

    // ====================================================================
    //  构建后操作
    // ====================================================================
    post {
        always {
            echo '构建流程结束。'
            cleanWs()
        }
    }
}
